//! IndexedDB Ref<T> Property Tests
//!
//! Tests for typed entity references with IndexedDB storage.
//! Verifies:
//! - Storing entities with Ref<T> properties
//! - Retrieving Ref<T> values
//! - Programmatic traversal via .get()

mod common;

use ankurah::property::Ref;
use ankurah::{policy::DEFAULT_CONTEXT, Context, Model, Node, PermissiveAgent};
use ankurah_storage_indexeddb_wasm::IndexedDBStorageEngine;
use common::setup;
use serde::{Deserialize, Serialize};
use std::sync::Arc;
use wasm_bindgen_test::*;

wasm_bindgen_test_configure!(run_in_browser);

/// Artist model for testing Ref traversal
#[derive(Model, Debug, Serialize, Deserialize, Clone)]
pub struct WasmRefArtist {
    pub name: String,
}

/// Album model with a Ref<Artist> field
/// Wrapper LWWRefWasmRefArtist is auto-generated by the Model derive macro
#[derive(Model, Debug, Serialize, Deserialize, Clone)]
pub struct WasmRefAlbum {
    pub name: String,
    pub artist: Ref<WasmRefArtist>,
}

async fn setup_context() -> Result<(Context, String), anyhow::Error> {
    setup();
    let db_name = format!("test_ref_{}", ulid::Ulid::new());
    let storage_engine = IndexedDBStorageEngine::open(&db_name).await?;
    let node = Node::new_durable(Arc::new(storage_engine), PermissiveAgent::new());
    node.system.create().await?;
    Ok((node.context_async(DEFAULT_CONTEXT).await, db_name))
}

#[wasm_bindgen_test]
async fn test_ref_basic_creation_wasm() -> Result<(), anyhow::Error> {
    let (ctx, db_name) = setup_context().await?;

    // Create an artist
    let artist_id = {
        let trx = ctx.begin();
        let artist = trx.create(&WasmRefArtist { name: "Radiohead".to_string() }).await?;
        let id = artist.id();
        trx.commit().await?;
        id
    };

    // Create an album referencing the artist
    let album_id = {
        let trx = ctx.begin();
        let album = trx.create(&WasmRefAlbum { name: "OK Computer".to_string(), artist: Ref::new(artist_id.clone()) }).await?;
        let id = album.id();
        trx.commit().await?;
        id
    };

    // Fetch the album and verify the ref is stored correctly
    let album: WasmRefAlbumView = ctx.get(album_id).await?;
    assert_eq!(album.name().unwrap(), "OK Computer");
    assert_eq!(album.artist().unwrap().id(), artist_id);

    IndexedDBStorageEngine::cleanup(&db_name).await?;
    Ok(())
}

#[wasm_bindgen_test]
async fn test_ref_traversal_wasm() -> Result<(), anyhow::Error> {
    let (ctx, db_name) = setup_context().await?;

    // Create an artist
    let artist_id = {
        let trx = ctx.begin();
        let artist = trx.create(&WasmRefArtist { name: "Muse".to_string() }).await?;
        let id = artist.id();
        trx.commit().await?;
        id
    };

    // Create an album referencing the artist
    let album_id = {
        let trx = ctx.begin();
        let album = trx.create(&WasmRefAlbum { name: "Origin of Symmetry".to_string(), artist: Ref::new(artist_id.clone()) }).await?;
        let id = album.id();
        trx.commit().await?;
        id
    };

    // Fetch the album, then traverse the ref to get the artist
    let album: WasmRefAlbumView = ctx.get(album_id).await?;
    let artist_ref = album.artist().unwrap();

    // Key test: calling .get() on the Ref to fetch the referenced entity
    let artist: WasmRefArtistView = artist_ref.get(&ctx).await?;
    assert_eq!(artist.name().unwrap(), "Muse");

    IndexedDBStorageEngine::cleanup(&db_name).await?;
    Ok(())
}
