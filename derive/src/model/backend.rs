use proc_macro2::TokenStream;
use quote::{format_ident, quote};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use syn::Type;

/// Backend configuration for code generation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BackendConfig {
    pub backend_name: String,
    pub namespace: String,
    pub provided_wrapper_types: Vec<String>,
    pub substitutions: HashMap<String, HashMap<String, String>>,
    pub values: Vec<ValueConfig>,
}

/// Configuration for a specific value type within a backend
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ValueConfig {
    pub type_pattern: String,
    pub fully_qualified_type: String,
    pub accepts: String,
    pub generic_params: Vec<String>,
    pub materialized_pattern: String,
    pub methods: Vec<Method>,
}

/// Method configuration for code generation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Method {
    pub name: String,
    pub args: Vec<(String, String)>, // (name, type)
    pub return_type: String,
    #[serde(default = "default_wasm_true")]
    pub wasm: bool,
}

fn default_wasm_true() -> bool { true }

/// Describes how to generate wrappers for a specific active field type
pub struct ActiveTypeDesc {
    pub(crate) backend_config: BackendConfig,
    pub(crate) value_config: ValueConfig,               // The specific ValueConfig that matched
    pub(crate) concrete_types: HashMap<String, String>, // {T} -> Complex, etc.
}

impl ActiveTypeDesc {
    /// Create an ActiveTypeDesc from config, value config, and concrete types
    pub fn new(backend_config: BackendConfig, value_config: ValueConfig, concrete_types: HashMap<String, String>) -> Self {
        Self { backend_config, value_config, concrete_types }
    }

    /// Get the wrapper type name for WASM bindings (just the identifier)
    pub fn wrapper_type_name(&self) -> String {
        let mut pattern = self.value_config.materialized_pattern.clone();

        // Substitute all generic parameters with their concrete types
        for param in &self.value_config.generic_params {
            if let Some(concrete_type) = self.concrete_types.get(param) {
                let placeholder = format!("{{{}}}", param);
                // Strip non-alphanumeric characters from each concrete type
                let sanitized_type: String = concrete_type.chars().filter(|c| c.is_alphanumeric()).collect();
                pattern = pattern.replace(&placeholder, &sanitized_type);
            }
        }

        pattern
    }

    /// Get the fully qualified wrapper type path for WASM bindings
    pub fn wrapper_type_path(&self, context: &str) -> String {
        let wrapper_name = self.wrapper_type_name();

        match context {
            "local" => {
                // For provided types generated by impl_provided_wrapper_types!()
                format!("{}::wasm::{}", self.backend_config.namespace, wrapper_name)
            }
            "external" => {
                // For custom types generated by impl_wrapper_type!() in current module
                wrapper_name
            }
            _ => wrapper_name,
        }
    }

    /// Determine if this type is provided by the backend or custom
    pub fn is_provided_type(&self) -> bool {
        // Check if any of the concrete types are in the provided_wrapper_types list
        for concrete_type in self.concrete_types.values() {
            if self.backend_config.provided_wrapper_types.contains(concrete_type) {
                return true;
            }
        }
        false
    }

    /// Get the appropriate fully qualified wrapper type path
    pub fn get_wrapper_type_path(&self) -> String {
        if self.is_provided_type() {
            self.wrapper_type_path("local")
        } else {
            self.wrapper_type_path("external")
        }
    }

    /// Get the wrapper type for WASM bindings
    #[allow(unused)]
    pub fn wrapper_type(&self) -> syn::Result<syn::Type> {
        let wrapper_name = self.wrapper_type_name();
        syn::parse_str(&wrapper_name)
    }

    #[allow(unused)]
    pub fn rust_type_name(&self) -> String {
        let rust_type = self.rust_type().unwrap();
        quote!(#rust_type).to_string()
    }

    /// Get the fully qualified Rust type for accessor methods
    pub fn rust_type(&self) -> syn::Result<syn::Type> { self.rust_type_with_context("external") }

    /// Get the fully qualified Rust type for accessor methods with explicit context
    pub fn rust_type_with_context(&self, context: &str) -> syn::Result<syn::Type> {
        let mut type_str = self.value_config.fully_qualified_type.clone();

        // Apply context-specific substitutions first
        if let Some(context_substitutions) = self.backend_config.substitutions.get(context) {
            for (token, replacement) in context_substitutions {
                let placeholder = format!("{{{}}}", token);
                type_str = type_str.replace(&placeholder, replacement);
            }
        }

        // Substitute {T} with actual concrete types
        for (param, concrete_type) in &self.concrete_types {
            let placeholder = format!("{{{}}}", param);
            type_str = type_str.replace(&placeholder, concrete_type);
        }

        syn::parse_str(&type_str)
    }

    /// Generate the materialized wrapper struct with context-specific substitutions
    pub fn generate_wrapper(&self, context: &str) -> TokenStream {
        // For now, assume single value config
        let value_config = &self.backend_config.values[0];

        let wrapper_name = format_ident!("{}", self.wrapper_type_name());
        let original_type: Type = self.rust_type_with_context(context).expect("Failed to parse original type");

        let substitute_fn = |backend: &ActiveTypeDesc, pattern: &str| backend.do_substitutions(pattern, context);

        // Generate method implementations (only for methods with wasm: true)
        let methods: Vec<TokenStream> = value_config
            .methods
            .iter()
            .filter(|method| method.wasm)
            .map(|method| {
                let method_name = format_ident!("{}", method.name);
                let args: Vec<TokenStream> = method
                    .args
                    .iter()
                    .map(|(arg_name, arg_type)| {
                        let arg_name = format_ident!("{}", arg_name);
                        let arg_type = substitute_fn(self, arg_type);
                        let arg_type: Type = syn::parse_str(&arg_type).expect("Failed to parse arg type");
                        quote! { #arg_name: #arg_type }
                    })
                    .collect();

                let return_type_str = substitute_fn(self, &method.return_type);

                // Generate method call: self.0.method_name(args...)
                let arg_names: Vec<syn::Ident> = method.args.iter().map(|(name, _)| format_ident!("{}", name)).collect();

                // Handle argument conversion for WASM (e.g., value -> &value for LWW::set)
                let converted_args: Vec<TokenStream> = method
                    .args
                    .iter()
                    .zip(arg_names.iter())
                    .map(|((_, arg_type), arg_name)| {
                        if arg_type == "{T}" && method.name == "set" {
                            // For LWW::set and similar, convert value parameter to reference
                            quote! { &#arg_name }
                        } else {
                            quote! { #arg_name }
                        }
                    })
                    .collect();

                // Handle Result types properly - don't double-wrap
                let (wasm_return_type_str, method_call) = if return_type_str.starts_with("Result<") {
                    // Already a Result, just change the error type
                    let inner_type = return_type_str.strip_prefix("Result<").unwrap().strip_suffix(">").unwrap();
                    let parts: Vec<&str> = inner_type.split(", ").collect();
                    let ok_type = parts[0];
                    (
                        format!("Result<{}, ::wasm_bindgen::JsValue>", ok_type),
                        quote! {
                            self.0.#method_name(#(#converted_args),*)
                                .map_err(|e| ::wasm_bindgen::JsValue::from(e.to_string()))
                        },
                    )
                } else {
                    // Not a Result, return directly
                    (return_type_str.clone(), quote! { self.0.#method_name(#(#converted_args),*) })
                };

                let wasm_return_type: Type = syn::parse_str(&wasm_return_type_str).expect("Failed to parse return type");

                quote! {
                    pub fn #method_name(&self, #(#args),*) -> #wasm_return_type {
                        #method_call
                    }
                }
            })
            .collect();

        quote! {
            #[wasm_bindgen]
            pub struct #wrapper_name( #[wasm_bindgen(skip)] pub #original_type);


            #[wasm_bindgen]
            impl #wrapper_name {
                #(#methods)*
            }
        }
    }

    /// Substitute generic parameters in type/method signatures
    fn substitute_generics(&self, pattern: &str) -> String {
        let mut result = pattern.to_string();
        for (param, concrete_type) in &self.concrete_types {
            let placeholder = format!("{{{}}}", param);
            result = result.replace(&placeholder, concrete_type);
        }
        result
    }

    /// Substitute generic parameters and context-specific tokens
    fn do_substitutions(&self, pattern: &str, context: &str) -> String {
        let mut result = self.substitute_generics(pattern);

        // Apply context-specific substitutions
        if let Some(context_substitutions) = self.backend_config.substitutions.get(context) {
            for (token, replacement) in context_substitutions {
                let placeholder = format!("{{{}}}", token);
                result = result.replace(&placeholder, replacement);
            }
        }

        result
    }
}

#[cfg(test)]
mod tests {
    use maplit::hashmap;

    use super::*;

    #[test]
    fn test_materialized_name_simple() {
        let backend_config = BackendConfig {
            backend_name: "LWW".to_string(),
            namespace: "test".to_string(),
            provided_wrapper_types: vec![],
            substitutions: HashMap::new(),
            values: vec![],
        };

        let value_config = ValueConfig {
            type_pattern: "LWW(?:<(.+)>)?".to_string(),
            fully_qualified_type: "LWW<{T}>".to_string(),
            accepts: ".*".to_string(),
            generic_params: vec!["T".to_string()],
            materialized_pattern: "LWW{T}".to_string(),
            methods: vec![],
        };

        let desc = ActiveTypeDesc::new(backend_config.clone(), value_config.clone(), hashmap! { "T".into() => "String".into() });
        assert_eq!(desc.wrapper_type_name(), "LWWString");

        let desc =
            ActiveTypeDesc::new(backend_config.clone(), value_config.clone(), hashmap! { "T".into() => "HashMap<String, i32>".into() });
        assert_eq!(desc.wrapper_type_name(), "LWWHashMapStringi32");
    }
}
